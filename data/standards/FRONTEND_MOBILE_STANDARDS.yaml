name: Docs/Standards/Frontend Mobile Standards
category: general
filename: docs/standards/FRONTEND_MOBILE_STANDARDS.md
nist_controls: []
sections:
  Frontend and Mobile Development Standards: '**Version:** 1.0.0

    **Last Updated:** January 2025

    **Status:** Active

    **Standard Code:** FE


    ---


    **Version:** 1.0.0

    **Last Updated:** January 2025

    **Status:** Active'
  Table of Contents: '1. [Frontend Architecture Standards](#1-frontend-architecture-standards)

    2. [React/Vue/Angular Standards](#2-reactvueangular-standards)

    3. [State Management](#3-state-management)

    4. [Performance and Optimization](#4-performance-and-optimization)

    5. [Progressive Web Apps (PWA)](#5-progressive-web-apps-pwa)

    6. [Mobile Development Standards](#6-mobile-development-standards)

    7. [UI/UX Standards](#7-uiux-standards)

    8. [Testing and Quality Assurance](#8-testing-and-quality-assurance)


    ---'
  Overview: 'This standard provides comprehensive guidelines and best practices for
    the subject area.

    It aims to ensure consistency, quality, and maintainability across all related
    implementations.'
  1. Frontend Architecture Standards: "### 1.1 Project Structure\n\n#### Modern Frontend\
    \ Structure **[REQUIRED]**\n```\nfrontend-app/\n\u251C\u2500\u2500 public/   \
    \                  # Static assets\n\u2502   \u251C\u2500\u2500 index.html\n\u2502\
    \   \u251C\u2500\u2500 favicon.ico\n\u2502   \u2514\u2500\u2500 manifest.json\n\
    \u251C\u2500\u2500 src/\n\u2502   \u251C\u2500\u2500 components/            #\
    \ Reusable UI components\n\u2502   \u2502   \u251C\u2500\u2500 common/       \
    \    # Generic components\n\u2502   \u2502   \u251C\u2500\u2500 forms/       \
    \     # Form components\n\u2502   \u2502   \u2514\u2500\u2500 layout/        \
    \   # Layout components\n\u2502   \u251C\u2500\u2500 pages/                # Page-level\
    \ components\n\u2502   \u2502   \u251C\u2500\u2500 Home/\n\u2502   \u2502   \u251C\
    \u2500\u2500 Profile/\n\u2502   \u2502   \u2514\u2500\u2500 Settings/\n\u2502\
    \   \u251C\u2500\u2500 hooks/                # Custom React hooks\n\u2502   \u251C\
    \u2500\u2500 services/             # API and external services\n\u2502   \u251C\
    \u2500\u2500 store/                # State management\n\u2502   \u251C\u2500\u2500\
    \ utils/                # Utility functions\n\u2502   \u251C\u2500\u2500 types/\
    \                # TypeScript type definitions\n\u2502   \u251C\u2500\u2500 styles/\
    \               # Global styles and themes\n\u2502   \u251C\u2500\u2500 assets/\
    \               # Images, fonts, icons\n\u2502   \u251C\u2500\u2500 constants/\
    \            # App constants\n\u2502   \u2514\u2500\u2500 __tests__/         \
    \   # Test files\n\u251C\u2500\u2500 docs/                     # Documentation\n\
    \u251C\u2500\u2500 scripts/                  # Build and utility scripts\n\u251C\
    \u2500\u2500 .env.example             # Environment variables template\n\u251C\
    \u2500\u2500 .eslintrc.js             # ESLint configuration\n\u251C\u2500\u2500\
    \ .prettierrc              # Prettier configuration\n\u251C\u2500\u2500 tsconfig.json\
    \            # TypeScript configuration\n\u251C\u2500\u2500 package.json\n\u2514\
    \u2500\u2500 webpack.config.js        # Build configuration\n```\n\n#### Component\
    \ Organization **[REQUIRED]**\n```typescript\n// components/Button/index.ts\n\
    export { Button } from './Button';\nexport type { ButtonProps } from './Button.types';\n\
    \n// components/Button/Button.types.ts\nexport interface ButtonProps {\n  children:\
    \ React.ReactNode;\n  variant?: 'primary' | 'secondary' | 'danger';\n  size?:\
    \ 'small' | 'medium' | 'large';\n  disabled?: boolean;\n  loading?: boolean;\n\
    \  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;\n  'data-testid'?:\
    \ string;\n}\n\n// components/Button/Button.tsx\nimport React from 'react';\n\
    import { ButtonProps } from './Button.types';\nimport { StyledButton, LoadingSpinner\
    \ } from './Button.styles';\n\nexport const Button: React.FC<ButtonProps> = ({\n\
    \  children,\n  variant = 'primary',\n  size = 'medium',\n  disabled = false,\n\
    \  loading = false,\n  onClick,\n  'data-testid': testId,\n  ...props\n}) => {\n\
    \  return (\n    <StyledButton\n      variant={variant}\n      size={size}\n \
    \     disabled={disabled || loading}\n      onClick={onClick}\n      data-testid={testId}\n\
    \      {...props}\n    >\n      {loading && <LoadingSpinner />}\n      {children}\n\
    \    </StyledButton>\n  );\n};\n\n// components/Button/Button.test.tsx\nimport\
    \ { render, screen, fireEvent } from '@testing-library/react';\nimport { Button\
    \ } from './Button';\n\ndescribe('Button', () => {\n  it('renders children correctly',\
    \ () => {\n    render(<Button>Click me</Button>);\n    expect(screen.getByText('Click\
    \ me')).toBeInTheDocument();\n  });\n\n  it('calls onClick when clicked', () =>\
    \ {\n    const handleClick = jest.fn();\n    render(<Button onClick={handleClick}>Click\
    \ me</Button>);\n\n    fireEvent.click(screen.getByText('Click me'));\n    expect(handleClick).toHaveBeenCalledTimes(1);\n\
    \  });\n\n  it('shows loading state', () => {\n    render(<Button loading>Click\
    \ me</Button>);\n    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();\n\
    \  });\n});\n```\n\n### 1.2 TypeScript Configuration\n\n#### Strict TypeScript\
    \ Setup **[REQUIRED]**\n```json\n{\n  \"compilerOptions\": {\n    \"target\":\
    \ \"ES2020\",\n    \"lib\": [\"DOM\", \"DOM.Iterable\", \"ES2020\"],\n    \"allowJs\"\
    : true,\n    \"skipLibCheck\": true,\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\"\
    : true,\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"noImplicitReturns\"\
    : true,\n    \"noImplicitThis\": true,\n    \"noUnusedLocals\": true,\n    \"\
    noUnusedParameters\": true,\n    \"exactOptionalPropertyTypes\": true,\n    \"\
    forceConsistentCasingInFileNames\": true,\n    \"module\": \"esnext\",\n    \"\
    moduleResolution\": \"node\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\"\
    : true,\n    \"noEmit\": true,\n    \"jsx\": \"react-jsx\",\n    \"baseUrl\":\
    \ \"src\",\n    \"paths\": {\n      \"@components/*\": [\"components/*\"],\n \
    \     \"@pages/*\": [\"pages/*\"],\n      \"@utils/*\": [\"utils/*\"],\n     \
    \ \"@types/*\": [\"types/*\"],\n      \"@services/*\": [\"services/*\"],\n   \
    \   \"@store/*\": [\"store/*\"]\n    }\n  },\n  \"include\": [\n    \"src/**/*\"\
    ,\n    \"src/**/*.json\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"\
    build\",\n    \"dist\"\n  ]\n}\n```\n\n#### Type Safety Patterns **[REQUIRED]**\n\
    ```typescript\n// types/api.types.ts\nexport interface ApiResponse<T> {\n  data:\
    \ T;\n  success: boolean;\n  message?: string;\n  errors?: string[];\n}\n\nexport\
    \ interface User {\n  id: string;\n  email: string;\n  name: string;\n  avatar?:\
    \ string;\n  role: UserRole;\n  createdAt: string;\n  updatedAt: string;\n}\n\n\
    export enum UserRole {\n  ADMIN = 'admin',\n  USER = 'user',\n  MODERATOR = 'moderator'\n\
    }\n\n// services/api.service.ts\nimport { ApiResponse, User } from '@types/api.types';\n\
    \nclass ApiService {\n  private baseURL = process.env.REACT_APP_API_URL || '';\n\
    \n  private async request<T>(\n    endpoint: string,\n    options: RequestInit\
    \ = {}\n  ): Promise<ApiResponse<T>> {\n    try {\n      const response = await\
    \ fetch(`${this.baseURL}${endpoint}`, {\n        headers: {\n          'Content-Type':\
    \ 'application/json',\n          ...options.headers,\n        },\n        ...options,\n\
    \      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error!\
    \ status: ${response.status}`);\n      }\n\n      const data: ApiResponse<T> =\
    \ await response.json();\n      return data;\n    } catch (error) {\n      throw\
    \ new Error(`API request failed: ${error}`);\n    }\n  }\n\n  async getUser(id:\
    \ string): Promise<User> {\n    const response = await this.request<User>(`/users/${id}`);\n\
    \    if (!response.success) {\n      throw new Error(response.message || 'Failed\
    \ to fetch user');\n    }\n    return response.data;\n  }\n\n  async updateUser(id:\
    \ string, updates: Partial<User>): Promise<User> {\n    const response = await\
    \ this.request<User>(`/users/${id}`, {\n      method: 'PATCH',\n      body: JSON.stringify(updates),\n\
    \    });\n\n    if (!response.success) {\n      throw new Error(response.message\
    \ || 'Failed to update user');\n    }\n\n    return response.data;\n  }\n}\n\n\
    export const apiService = new ApiService();\n```\n\n### 1.3 Build and Bundling\n\
    \n#### Webpack Configuration **[REQUIRED]**\n```javascript\n// webpack.config.js\n\
    const path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\
    const MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst { BundleAnalyzerPlugin\
    \ } = require('webpack-bundle-analyzer');\n\nconst isProduction = process.env.NODE_ENV\
    \ === 'production';\n\nmodule.exports = {\n  mode: isProduction ? 'production'\
    \ : 'development',\n  entry: './src/index.tsx',\n\n  output: {\n    path: path.resolve(__dirname,\
    \ 'dist'),\n    filename: isProduction\n      ? '[name].[contenthash].js'\n  \
    \    : '[name].js',\n    chunkFilename: isProduction\n      ? '[name].[contenthash].chunk.js'\n\
    \      : '[name].chunk.js',\n    clean: true,\n    publicPath: '/',\n  },\n\n\
    \  resolve: {\n    extensions: ['.tsx', '.ts', '.js', '.jsx'],\n    alias: {\n\
    \      '@components': path.resolve(__dirname, 'src/components'),\n      '@pages':\
    \ path.resolve(__dirname, 'src/pages'),\n      '@utils': path.resolve(__dirname,\
    \ 'src/utils'),\n      '@types': path.resolve(__dirname, 'src/types'),\n     \
    \ '@services': path.resolve(__dirname, 'src/services'),\n      '@store': path.resolve(__dirname,\
    \ 'src/store'),\n    },\n  },\n\n  module: {\n    rules: [\n      {\n        test:\
    \ /\\.(ts|tsx)$/,\n        use: 'ts-loader',\n        exclude: /node_modules/,\n\
    \      },\n      {\n        test: /\\.css$/i,\n        use: [\n          isProduction\
    \ ? MiniCssExtractPlugin.loader : 'style-loader',\n          'css-loader',\n \
    \         'postcss-loader',\n        ],\n      },\n      {\n        test: /\\\
    .(png|jpe?g|gif|svg)$/i,\n        type: 'asset/resource',\n        generator:\
    \ {\n          filename: 'images/[name].[hash][ext]',\n        },\n      },\n\
    \    ],\n  },\n\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './public/index.html',\n\
    \      minify: isProduction,\n    }),\n    ...(isProduction\n      ? [\n     \
    \     new MiniCssExtractPlugin({\n            filename: '[name].[contenthash].css',\n\
    \          }),\n        ]\n      : []\n    ),\n    ...(process.env.ANALYZE ===\
    \ 'true'\n      ? [new BundleAnalyzerPlugin()]\n      : []\n    ),\n  ],\n\n \
    \ optimization: {\n    splitChunks: {\n      chunks: 'all',\n      cacheGroups:\
    \ {\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n      \
    \    name: 'vendors',\n          chunks: 'all',\n        },\n      },\n    },\n\
    \  },\n\n  devServer: {\n    contentBase: path.join(__dirname, 'dist'),\n    compress:\
    \ true,\n    port: 3000,\n    historyApiFallback: true,\n    hot: true,\n  },\n\
    };\n```\n\n---"
  2. React/Vue/Angular Standards: "### 2.1 React Standards\n\n#### Component Patterns\
    \ **[REQUIRED]**\n```typescript\n// Custom Hooks Pattern\nimport { useState, useEffect,\
    \ useCallback } from 'react';\nimport { apiService } from '@services/api.service';\n\
    import { User } from '@types/api.types';\n\ninterface UseUserResult {\n  user:\
    \ User | null;\n  loading: boolean;\n  error: string | null;\n  refetch: () =>\
    \ void;\n}\n\nexport const useUser = (userId: string): UseUserResult => {\n  const\
    \ [user, setUser] = useState<User | null>(null);\n  const [loading, setLoading]\
    \ = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\
    \n  const fetchUser = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n\
    \n    try {\n      const userData = await apiService.getUser(userId);\n      setUser(userData);\n\
    \    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed\
    \ to fetch user');\n    } finally {\n      setLoading(false);\n    }\n  }, [userId]);\n\
    \n  useEffect(() => {\n    fetchUser();\n  }, [fetchUser]);\n\n  return {\n  \
    \  user,\n    loading,\n    error,\n    refetch: fetchUser,\n  };\n};\n\n// Higher-Order\
    \ Component for Error Boundary\nimport React, { Component, ErrorInfo, ReactNode\
    \ } from 'react';\n\ninterface Props {\n  children: ReactNode;\n  fallback?: ReactNode;\n\
    \  onError?: (error: Error, errorInfo: ErrorInfo) => void;\n}\n\ninterface State\
    \ {\n  hasError: boolean;\n  error?: Error;\n}\n\nexport class ErrorBoundary extends\
    \ Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n\
    \    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error:\
    \ Error): State {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error:\
    \ Error, errorInfo: ErrorInfo) {\n    console.error('Error caught by boundary:',\
    \ error, errorInfo);\n    this.props.onError?.(error, errorInfo);\n  }\n\n  render()\
    \ {\n    if (this.state.hasError) {\n      return this.props.fallback || (\n \
    \       <div className=\"error-fallback\">\n          <h2>Something went wrong.</h2>\n\
    \          <button onClick={() => this.setState({ hasError: false })}>\n     \
    \       Try again\n          </button>\n        </div>\n      );\n    }\n\n  \
    \  return this.props.children;\n  }\n}\n\n// Compound Component Pattern\ninterface\
    \ TabsProps {\n  children: ReactNode;\n  defaultTab?: string;\n  onTabChange?:\
    \ (tabId: string) => void;\n}\n\ninterface TabListProps {\n  children: ReactNode;\n\
    }\n\ninterface TabProps {\n  id: string;\n  children: ReactNode;\n}\n\ninterface\
    \ TabPanelsProps {\n  children: ReactNode;\n}\n\ninterface TabPanelProps {\n \
    \ id: string;\n  children: ReactNode;\n}\n\nconst TabsContext = React.createContext<{\n\
    \  activeTab: string;\n  setActiveTab: (id: string) => void;\n} | null>(null);\n\
    \nexport const Tabs: React.FC<TabsProps> & {\n  List: React.FC<TabListProps>;\n\
    \  Tab: React.FC<TabProps>;\n  Panels: React.FC<TabPanelsProps>;\n  Panel: React.FC<TabPanelProps>;\n\
    } = ({ children, defaultTab, onTabChange }) => {\n  const [activeTab, setActiveTab]\
    \ = useState(defaultTab || '');\n\n  const handleTabChange = (tabId: string) =>\
    \ {\n    setActiveTab(tabId);\n    onTabChange?.(tabId);\n  };\n\n  return (\n\
    \    <TabsContext.Provider value={{ activeTab, setActiveTab: handleTabChange }}>\n\
    \      <div className=\"tabs\">{children}</div>\n    </TabsContext.Provider>\n\
    \  );\n};\n\nTabs.List = ({ children }) => (\n  <div className=\"tab-list\" role=\"\
    tablist\">{children}</div>\n);\n\nTabs.Tab = ({ id, children }) => {\n  const\
    \ context = useContext(TabsContext);\n  if (!context) throw new Error('Tab must\
    \ be used within Tabs');\n\n  const { activeTab, setActiveTab } = context;\n\n\
    \  return (\n    <button\n      role=\"tab\"\n      aria-selected={activeTab ===\
    \ id}\n      onClick={() => setActiveTab(id)}\n      className={`tab ${activeTab\
    \ === id ? 'active' : ''}`}\n    >\n      {children}\n    </button>\n  );\n};\n\
    \nTabs.Panels = ({ children }) => (\n  <div className=\"tab-panels\">{children}</div>\n\
    );\n\nTabs.Panel = ({ id, children }) => {\n  const context = useContext(TabsContext);\n\
    \  if (!context) throw new Error('TabPanel must be used within Tabs');\n\n  const\
    \ { activeTab } = context;\n\n  if (activeTab !== id) return null;\n\n  return\
    \ (\n    <div role=\"tabpanel\" className=\"tab-panel\">\n      {children}\n \
    \   </div>\n  );\n};\n```\n\n#### Performance Optimization **[REQUIRED]**\n```typescript\n\
    // Memoization and optimization patterns\nimport React, { memo, useMemo, useCallback\
    \ } from 'react';\n\ninterface ExpensiveListProps {\n  items: Array<{ id: string;\
    \ name: string; value: number }>;\n  filter: string;\n  onItemClick: (id: string)\
    \ => void;\n}\n\nexport const ExpensiveList = memo<ExpensiveListProps>(({\n  items,\n\
    \  filter,\n  onItemClick\n}) => {\n  // Memoize expensive computations\n  const\
    \ filteredItems = useMemo(() => {\n    return items.filter(item =>\n      item.name.toLowerCase().includes(filter.toLowerCase())\n\
    \    );\n  }, [items, filter]);\n\n  const sortedItems = useMemo(() => {\n   \
    \ return [...filteredItems].sort((a, b) => b.value - a.value);\n  }, [filteredItems]);\n\
    \n  // Memoize callbacks to prevent unnecessary re-renders\n  const handleItemClick\
    \ = useCallback((id: string) => {\n    onItemClick(id);\n  }, [onItemClick]);\n\
    \n  return (\n    <div className=\"expensive-list\">\n      {sortedItems.map(item\
    \ => (\n        <ExpensiveListItem\n          key={item.id}\n          item={item}\n\
    \          onClick={handleItemClick}\n        />\n      ))}\n    </div>\n  );\n\
    });\n\n// Separate component for individual items\ninterface ExpensiveListItemProps\
    \ {\n  item: { id: string; name: string; value: number };\n  onClick: (id: string)\
    \ => void;\n}\n\nconst ExpensiveListItem = memo<ExpensiveListItemProps>(({ item,\
    \ onClick }) => {\n  const handleClick = useCallback(() => {\n    onClick(item.id);\n\
    \  }, [item.id, onClick]);\n\n  return (\n    <div className=\"list-item\" onClick={handleClick}>\n\
    \      <span>{item.name}</span>\n      <span>{item.value}</span>\n    </div>\n\
    \  );\n});\n\n// Code splitting with React.lazy\nimport { lazy, Suspense } from\
    \ 'react';\n\nconst LazyDashboard = lazy(() => import('@pages/Dashboard'));\n\
    const LazyProfile = lazy(() => import('@pages/Profile'));\nconst LazySettings\
    \ = lazy(() => import('@pages/Settings'));\n\nexport const AppRouter: React.FC\
    \ = () => {\n  return (\n    <Router>\n      <Suspense fallback={<LoadingSpinner\
    \ />}>\n        <Routes>\n          <Route\n            path=\"/dashboard\"\n\
    \            element={<LazyDashboard />}\n          />\n          <Route\n   \
    \         path=\"/profile\"\n            element={<LazyProfile />}\n         \
    \ />\n          <Route\n            path=\"/settings\"\n            element={<LazySettings\
    \ />}\n          />\n        </Routes>\n      </Suspense>\n    </Router>\n  );\n\
    };\n```\n\n### 2.2 Vue.js Standards\n\n#### Composition API Patterns **[REQUIRED]**\n\
    ```vue\n<!-- UserProfile.vue -->\n<template>\n  <div class=\"user-profile\">\n\
    \    <div v-if=\"loading\" class=\"loading\">Loading...</div>\n    <div v-else-if=\"\
    error\" class=\"error\">{{ error }}</div>\n    <div v-else-if=\"user\" class=\"\
    user-content\">\n      <h1>{{ user.name }}</h1>\n      <p>{{ user.email }}</p>\n\
    \      <button @click=\"updateProfile\" :disabled=\"updating\">\n        {{ updating\
    \ ? 'Updating...' : 'Update Profile' }}\n      </button>\n    </div>\n  </div>\n\
    </template>\n\n<script setup lang=\"ts\">\nimport { ref, computed, watch, onMounted\
    \ } from 'vue';\nimport { useUser } from '@/composables/useUser';\nimport type\
    \ { User } from '@/types/user';\n\ninterface Props {\n  userId: string;\n}\n\n\
    const props = defineProps<Props>();\n\n// Use composable for user management\n\
    const {\n  user,\n  loading,\n  error,\n  fetchUser,\n  updateUser\n} = useUser();\n\
    \nconst updating = ref(false);\n\n// Computed properties\nconst displayName =\
    \ computed(() => {\n  return user.value ? `${user.value.firstName} ${user.value.lastName}`\
    \ : '';\n});\n\n// Watch for prop changes\nwatch(() => props.userId, (newId) =>\
    \ {\n  if (newId) {\n    fetchUser(newId);\n  }\n}, { immediate: true });\n\n\
    // Methods\nconst updateProfile = async () => {\n  if (!user.value) return;\n\n\
    \  updating.value = true;\n  try {\n    await updateUser(user.value.id, {\n  \
    \    lastActive: new Date().toISOString()\n    });\n  } catch (err) {\n    console.error('Failed\
    \ to update profile:', err);\n  } finally {\n    updating.value = false;\n  }\n\
    };\n\n// Lifecycle\nonMounted(() => {\n  console.log('UserProfile component mounted');\n\
    });\n</script>\n\n<style scoped>\n.user-profile {\n  padding: 1rem;\n}\n\n.loading,\
    \ .error {\n  text-align: center;\n  padding: 2rem;\n}\n\n.error {\n  color: var(--color-error);\n\
    }\n\n.user-content {\n  max-width: 600px;\n  margin: 0 auto;\n}\n</style>\n```\n\
    \n```typescript\n// composables/useUser.ts\nimport { ref, reactive } from 'vue';\n\
    import type { Ref } from 'vue';\nimport { apiService } from '@/services/api';\n\
    import type { User } from '@/types/user';\n\ninterface UseUserReturn {\n  user:\
    \ Ref<User | null>;\n  loading: Ref<boolean>;\n  error: Ref<string | null>;\n\
    \  fetchUser: (id: string) => Promise<void>;\n  updateUser: (id: string, data:\
    \ Partial<User>) => Promise<void>;\n}\n\nexport function useUser(): UseUserReturn\
    \ {\n  const user = ref<User | null>(null);\n  const loading = ref(false);\n \
    \ const error = ref<string | null>(null);\n\n  const fetchUser = async (id: string)\
    \ => {\n    loading.value = true;\n    error.value = null;\n\n    try {\n    \
    \  const response = await apiService.getUser(id);\n      user.value = response.data;\n\
    \    } catch (err) {\n      error.value = err instanceof Error ? err.message :\
    \ 'Failed to fetch user';\n    } finally {\n      loading.value = false;\n   \
    \ }\n  };\n\n  const updateUser = async (id: string, data: Partial<User>) => {\n\
    \    try {\n      const response = await apiService.updateUser(id, data);\n  \
    \    user.value = response.data;\n    } catch (err) {\n      error.value = err\
    \ instanceof Error ? err.message : 'Failed to update user';\n      throw err;\n\
    \    }\n  };\n\n  return {\n    user,\n    loading,\n    error,\n    fetchUser,\n\
    \    updateUser\n  };\n}\n```\n\n### 2.3 Angular Standards\n\n#### Component and\
    \ Service Patterns **[REQUIRED]**\n```typescript\n// user-profile.component.ts\n\
    import { Component, Input, OnInit, OnDestroy, ChangeDetectionStrategy } from '@angular/core';\n\
    import { Observable, Subject, BehaviorSubject, combineLatest } from 'rxjs';\n\
    import { takeUntil, map, catchError, startWith } from 'rxjs/operators';\nimport\
    \ { UserService } from '@services/user.service';\nimport { User } from '@models/user.model';\n\
    \n@Component({\n  selector: 'app-user-profile',\n  templateUrl: './user-profile.component.html',\n\
    \  styleUrls: ['./user-profile.component.scss'],\n  changeDetection: ChangeDetectionStrategy.OnPush\n\
    })\nexport class UserProfileComponent implements OnInit, OnDestroy {\n  @Input()\
    \ userId!: string;\n\n  private destroy$ = new Subject<void>();\n  private userId$\
    \ = new BehaviorSubject<string>('');\n\n  user$: Observable<User | null>;\n  loading$:\
    \ Observable<boolean>;\n  error$: Observable<string | null>;\n\n  constructor(private\
    \ userService: UserService) {\n    // Reactive data streams\n    this.user$ =\
    \ this.userId$.pipe(\n      switchMap(id =>\n        id ? this.userService.getUser(id)\
    \ : of(null)\n      ),\n      catchError(error => {\n        console.error('Error\
    \ fetching user:', error);\n        return of(null);\n      }),\n      takeUntil(this.destroy$)\n\
    \    );\n\n    this.loading$ = this.userService.loading$;\n    this.error$ = this.userService.error$;\n\
    \  }\n\n  ngOnInit(): void {\n    this.userId$.next(this.userId);\n  }\n\n  ngOnDestroy():\
    \ void {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n\n  onUpdateProfile(userData:\
    \ Partial<User>): void {\n    if (this.userId) {\n      this.userService.updateUser(this.userId,\
    \ userData);\n    }\n  }\n\n  trackByFn(index: number, item: any): any {\n   \
    \ return item.id || index;\n  }\n}\n\n// user.service.ts\nimport { Injectable\
    \ } from '@angular/core';\nimport { HttpClient, HttpErrorResponse } from '@angular/common/http';\n\
    import { BehaviorSubject, Observable, throwError } from 'rxjs';\nimport { map,\
    \ catchError, finalize } from 'rxjs/operators';\nimport { environment } from '@environments/environment';\n\
    import { User } from '@models/user.model';\nimport { ApiResponse } from '@models/api.model';\n\
    \n@Injectable({\n  providedIn: 'root'\n})\nexport class UserService {\n  private\
    \ readonly baseUrl = `${environment.apiUrl}/users`;\n\n  private loadingSubject\
    \ = new BehaviorSubject<boolean>(false);\n  private errorSubject = new BehaviorSubject<string\
    \ | null>(null);\n\n  public loading$ = this.loadingSubject.asObservable();\n\
    \  public error$ = this.errorSubject.asObservable();\n\n  constructor(private\
    \ http: HttpClient) {}\n\n  getUser(id: string): Observable<User> {\n    this.setLoading(true);\n\
    \    this.setError(null);\n\n    return this.http.get<ApiResponse<User>>(`${this.baseUrl}/${id}`).pipe(\n\
    \      map(response => response.data),\n      catchError(this.handleError.bind(this)),\n\
    \      finalize(() => this.setLoading(false))\n    );\n  }\n\n  updateUser(id:\
    \ string, userData: Partial<User>): Observable<User> {\n    this.setLoading(true);\n\
    \    this.setError(null);\n\n    return this.http.patch<ApiResponse<User>>(`${this.baseUrl}/${id}`,\
    \ userData).pipe(\n      map(response => response.data),\n      catchError(this.handleError.bind(this)),\n\
    \      finalize(() => this.setLoading(false))\n    );\n  }\n\n  private setLoading(loading:\
    \ boolean): void {\n    this.loadingSubject.next(loading);\n  }\n\n  private setError(error:\
    \ string | null): void {\n    this.errorSubject.next(error);\n  }\n\n  private\
    \ handleError(error: HttpErrorResponse): Observable<never> {\n    let errorMessage\
    \ = 'An unknown error occurred';\n\n    if (error.error instanceof ErrorEvent)\
    \ {\n      errorMessage = `Client Error: ${error.error.message}`;\n    } else\
    \ {\n      errorMessage = `Server Error: ${error.status} - ${error.message}`;\n\
    \    }\n\n    this.setError(errorMessage);\n    return throwError(() => new Error(errorMessage));\n\
    \  }\n}\n```\n\n---"
  3. State Management: "### 3.1 Redux Toolkit Standards\n\n#### Store Configuration\
    \ **[REQUIRED]**\n```typescript\n// store/index.ts\nimport { configureStore }\
    \ from '@reduxjs/toolkit';\nimport { persistStore, persistReducer } from 'redux-persist';\n\
    import storage from 'redux-persist/lib/storage';\nimport { authSlice } from './slices/authSlice';\n\
    import { userSlice } from './slices/userSlice';\nimport { uiSlice } from './slices/uiSlice';\n\
    \nconst persistConfig = {\n  key: 'root',\n  storage,\n  whitelist: ['auth'],\
    \ // Only persist auth state\n};\n\nconst persistedAuthReducer = persistReducer(persistConfig,\
    \ authSlice.reducer);\n\nexport const store = configureStore({\n  reducer: {\n\
    \    auth: persistedAuthReducer,\n    user: userSlice.reducer,\n    ui: uiSlice.reducer,\n\
    \  },\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware({\n \
    \     serializableCheck: {\n        ignoredActions: ['persist/PERSIST', 'persist/REHYDRATE'],\n\
    \      },\n    }),\n  devTools: process.env.NODE_ENV !== 'production',\n});\n\n\
    export const persistor = persistStore(store);\n\nexport type RootState = ReturnType<typeof\
    \ store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n\n// store/slices/userSlice.ts\n\
    import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';\n\
    import { apiService } from '@services/api.service';\nimport { User } from '@types/api.types';\n\
    \ninterface UserState {\n  currentUser: User | null;\n  users: User[];\n  loading:\
    \ boolean;\n  error: string | null;\n}\n\nconst initialState: UserState = {\n\
    \  currentUser: null,\n  users: [],\n  loading: false,\n  error: null,\n};\n\n\
    // Async thunks\nexport const fetchUser = createAsyncThunk(\n  'user/fetchUser',\n\
    \  async (userId: string, { rejectWithValue }) => {\n    try {\n      const user\
    \ = await apiService.getUser(userId);\n      return user;\n    } catch (error)\
    \ {\n      return rejectWithValue(\n        error instanceof Error ? error.message\
    \ : 'Failed to fetch user'\n      );\n    }\n  }\n);\n\nexport const updateUser\
    \ = createAsyncThunk(\n  'user/updateUser',\n  async (\n    { userId, updates\
    \ }: { userId: string; updates: Partial<User> },\n    { rejectWithValue }\n  )\
    \ => {\n    try {\n      const user = await apiService.updateUser(userId, updates);\n\
    \      return user;\n    } catch (error) {\n      return rejectWithValue(\n  \
    \      error instanceof Error ? error.message : 'Failed to update user'\n    \
    \  );\n    }\n  }\n);\n\nconst userSlice = createSlice({\n  name: 'user',\n  initialState,\n\
    \  reducers: {\n    clearError: (state) => {\n      state.error = null;\n    },\n\
    \    setCurrentUser: (state, action: PayloadAction<User | null>) => {\n      state.currentUser\
    \ = action.payload;\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n\
    \      // Fetch user\n      .addCase(fetchUser.pending, (state) => {\n       \
    \ state.loading = true;\n        state.error = null;\n      })\n      .addCase(fetchUser.fulfilled,\
    \ (state, action) => {\n        state.loading = false;\n        state.currentUser\
    \ = action.payload;\n      })\n      .addCase(fetchUser.rejected, (state, action)\
    \ => {\n        state.loading = false;\n        state.error = action.payload as\
    \ string;\n      })\n      // Update user\n      .addCase(updateUser.fulfilled,\
    \ (state, action) => {\n        state.currentUser = action.payload;\n        //\
    \ Update in users array if it exists\n        const index = state.users.findIndex(u\
    \ => u.id === action.payload.id);\n        if (index !== -1) {\n          state.users[index]\
    \ = action.payload;\n        }\n      });\n  },\n});\n\nexport const { clearError,\
    \ setCurrentUser } = userSlice.actions;\nexport { userSlice };\n\n// hooks/useAppSelector.ts\n\
    import { useSelector, TypedUseSelectorHook } from 'react-redux';\nimport type\
    \ { RootState } from '@store/index';\n\nexport const useAppSelector: TypedUseSelectorHook<RootState>\
    \ = useSelector;\n\n// hooks/useAppDispatch.ts\nimport { useDispatch } from 'react-redux';\n\
    import type { AppDispatch } from '@store/index';\n\nexport const useAppDispatch\
    \ = () => useDispatch<AppDispatch>();\n```\n\n### 3.2 Zustand Standards\n\n####\
    \ Simple State Management **[RECOMMENDED]**\n```typescript\n// store/userStore.ts\n\
    import { create } from 'zustand';\nimport { devtools, persist } from 'zustand/middleware';\n\
    import { apiService } from '@services/api.service';\nimport { User } from '@types/api.types';\n\
    \ninterface UserState {\n  // State\n  currentUser: User | null;\n  users: User[];\n\
    \  loading: boolean;\n  error: string | null;\n\n  // Actions\n  setCurrentUser:\
    \ (user: User | null) => void;\n  fetchUser: (userId: string) => Promise<void>;\n\
    \  updateUser: (userId: string, updates: Partial<User>) => Promise<void>;\n  clearError:\
    \ () => void;\n  reset: () => void;\n}\n\nconst initialState = {\n  currentUser:\
    \ null,\n  users: [],\n  loading: false,\n  error: null,\n};\n\nexport const useUserStore\
    \ = create<UserState>()(\n  devtools(\n    persist(\n      (set, get) => ({\n\
    \        ...initialState,\n\n        setCurrentUser: (user) =>\n          set({\
    \ currentUser: user }, false, 'setCurrentUser'),\n\n        fetchUser: async (userId)\
    \ => {\n          set({ loading: true, error: null }, false, 'fetchUser/pending');\n\
    \n          try {\n            const user = await apiService.getUser(userId);\n\
    \            set(\n              { currentUser: user, loading: false },\n    \
    \          false,\n              'fetchUser/fulfilled'\n            );\n     \
    \     } catch (error) {\n            set(\n              {\n                error:\
    \ error instanceof Error ? error.message : 'Failed to fetch user',\n         \
    \       loading: false,\n              },\n              false,\n            \
    \  'fetchUser/rejected'\n            );\n          }\n        },\n\n        updateUser:\
    \ async (userId, updates) => {\n          set({ loading: true, error: null },\
    \ false, 'updateUser/pending');\n\n          try {\n            const user = await\
    \ apiService.updateUser(userId, updates);\n            set(\n              {\n\
    \                currentUser: user,\n                loading: false,\n       \
    \         users: get().users.map(u => u.id === userId ? user : u),\n         \
    \     },\n              false,\n              'updateUser/fulfilled'\n       \
    \     );\n          } catch (error) {\n            set(\n              {\n   \
    \             error: error instanceof Error ? error.message : 'Failed to update\
    \ user',\n                loading: false,\n              },\n              false,\n\
    \              'updateUser/rejected'\n            );\n          }\n        },\n\
    \n        clearError: () => set({ error: null }, false, 'clearError'),\n\n   \
    \     reset: () => set(initialState, false, 'reset'),\n      }),\n      {\n  \
    \      name: 'user-store',\n        partialize: (state) => ({\n          currentUser:\
    \ state.currentUser,\n        }),\n      }\n    ),\n    {\n      name: 'user-store',\n\
    \    }\n  )\n);\n\n// Selectors\nexport const useCurrentUser = () => useUserStore(state\
    \ => state.currentUser);\nexport const useUserLoading = () => useUserStore(state\
    \ => state.loading);\nexport const useUserError = () => useUserStore(state =>\
    \ state.error);\n```\n\n### 3.3 Context API Patterns\n\n#### Provider Pattern\
    \ **[REQUIRED]**\n```typescript\n// contexts/ThemeContext.tsx\nimport React, {\
    \ createContext, useContext, useReducer, ReactNode } from 'react';\n\ntype Theme\
    \ = 'light' | 'dark' | 'system';\n\ninterface ThemeState {\n  theme: Theme;\n\
    \  systemTheme: 'light' | 'dark';\n  effectiveTheme: 'light' | 'dark';\n}\n\n\
    type ThemeAction =\n  | { type: 'SET_THEME'; payload: Theme }\n  | { type: 'SET_SYSTEM_THEME';\
    \ payload: 'light' | 'dark' };\n\ninterface ThemeContextType {\n  state: ThemeState;\n\
    \  setTheme: (theme: Theme) => void;\n}\n\nconst ThemeContext = createContext<ThemeContextType\
    \ | null>(null);\n\nfunction themeReducer(state: ThemeState, action: ThemeAction):\
    \ ThemeState {\n  switch (action.type) {\n    case 'SET_THEME':\n      return\
    \ {\n        ...state,\n        theme: action.payload,\n        effectiveTheme:\n\
    \          action.payload === 'system' ? state.systemTheme : action.payload,\n\
    \      };\n    case 'SET_SYSTEM_THEME':\n      return {\n        ...state,\n \
    \       systemTheme: action.payload,\n        effectiveTheme:\n          state.theme\
    \ === 'system' ? action.payload : state.effectiveTheme,\n      };\n    default:\n\
    \      return state;\n  }\n}\n\nexport const ThemeProvider: React.FC<{ children:\
    \ ReactNode }> = ({ children }) => {\n  const [state, dispatch] = useReducer(themeReducer,\
    \ {\n    theme: 'system',\n    systemTheme: 'light',\n    effectiveTheme: 'light',\n\
    \  });\n\n  // Monitor system theme changes\n  useEffect(() => {\n    const mediaQuery\
    \ = window.matchMedia('(prefers-color-scheme: dark)');\n\n    const handleChange\
    \ = (e: MediaQueryListEvent) => {\n      dispatch({\n        type: 'SET_SYSTEM_THEME',\n\
    \        payload: e.matches ? 'dark' : 'light',\n      });\n    };\n\n    // Set\
    \ initial system theme\n    dispatch({\n      type: 'SET_SYSTEM_THEME',\n    \
    \  payload: mediaQuery.matches ? 'dark' : 'light',\n    });\n\n    mediaQuery.addEventListener('change',\
    \ handleChange);\n    return () => mediaQuery.removeEventListener('change', handleChange);\n\
    \  }, []);\n\n  const setTheme = (theme: Theme) => {\n    dispatch({ type: 'SET_THEME',\
    \ payload: theme });\n    localStorage.setItem('theme', theme);\n  };\n\n  const\
    \ value = {\n    state,\n    setTheme,\n  };\n\n  return (\n    <ThemeContext.Provider\
    \ value={value}>\n      {children}\n    </ThemeContext.Provider>\n  );\n};\n\n\
    export const useTheme = () => {\n  const context = useContext(ThemeContext);\n\
    \  if (!context) {\n    throw new Error('useTheme must be used within a ThemeProvider');\n\
    \  }\n  return context;\n};\n```\n\n---"
  4. Performance and Optimization: "### 4.1 Core Web Vitals\n\n#### Performance Monitoring\
    \ **[REQUIRED]**\n```typescript\n// utils/performance.ts\ninterface PerformanceMetrics\
    \ {\n  fcp: number; // First Contentful Paint\n  lcp: number; // Largest Contentful\
    \ Paint\n  fid: number; // First Input Delay\n  cls: number; // Cumulative Layout\
    \ Shift\n  ttfb: number; // Time to First Byte\n}\n\nclass PerformanceMonitor\
    \ {\n  private metrics: Partial<PerformanceMetrics> = {};\n\n  constructor() {\n\
    \    this.observePerformance();\n  }\n\n  private observePerformance() {\n   \
    \ // Observe FCP and LCP\n    new PerformanceObserver((list) => {\n      for (const\
    \ entry of list.getEntries()) {\n        if (entry.name === 'first-contentful-paint')\
    \ {\n          this.metrics.fcp = entry.startTime;\n        }\n        if (entry.entryType\
    \ === 'largest-contentful-paint') {\n          this.metrics.lcp = entry.startTime;\n\
    \        }\n      }\n    }).observe({ entryTypes: ['paint', 'largest-contentful-paint']\
    \ });\n\n    // Observe FID\n    new PerformanceObserver((list) => {\n      for\
    \ (const entry of list.getEntries()) {\n        this.metrics.fid = entry.processingStart\
    \ - entry.startTime;\n      }\n    }).observe({ entryTypes: ['first-input'] });\n\
    \n    // Observe CLS\n    new PerformanceObserver((list) => {\n      let clsValue\
    \ = 0;\n      for (const entry of list.getEntries()) {\n        if (!entry.hadRecentInput)\
    \ {\n          clsValue += entry.value;\n        }\n      }\n      this.metrics.cls\
    \ = clsValue;\n    }).observe({ entryTypes: ['layout-shift'] });\n\n    // Calculate\
    \ TTFB\n    window.addEventListener('load', () => {\n      const navigation =\
    \ performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;\n\
    \      this.metrics.ttfb = navigation.responseStart - navigation.requestStart;\n\
    \    });\n  }\n\n  getMetrics(): Partial<PerformanceMetrics> {\n    return { ...this.metrics\
    \ };\n  }\n\n  reportMetrics() {\n    // Report to analytics service\n    if (window.gtag)\
    \ {\n      Object.entries(this.metrics).forEach(([metric, value]) => {\n     \
    \   window.gtag('event', metric, {\n          custom_parameter_value: value,\n\
    \        });\n      });\n    }\n  }\n}\n\nexport const performanceMonitor = new\
    \ PerformanceMonitor();\n\n// Performance budget checker\nexport const checkPerformanceBudget\
    \ = () => {\n  const metrics = performanceMonitor.getMetrics();\n\n  const budget\
    \ = {\n    fcp: 1800, // 1.8s\n    lcp: 2500, // 2.5s\n    fid: 100,  // 100ms\n\
    \    cls: 0.1,  // 0.1\n    ttfb: 600, // 600ms\n  };\n\n  const violations =\
    \ Object.entries(budget)\n    .filter(([metric, threshold]) => {\n      const\
    \ value = metrics[metric as keyof PerformanceMetrics];\n      return value !==\
    \ undefined && value > threshold;\n    })\n    .map(([metric, threshold]) => ({\n\
    \      metric,\n      actual: metrics[metric as keyof PerformanceMetrics],\n \
    \     threshold,\n    }));\n\n  if (violations.length > 0) {\n    console.warn('Performance\
    \ budget violations:', violations);\n  }\n\n  return violations;\n};\n```\n\n\
    #### Image Optimization **[REQUIRED]**\n```typescript\n// components/OptimizedImage.tsx\n\
    import React, { useState, useRef, useEffect } from 'react';\n\ninterface OptimizedImageProps\
    \ {\n  src: string;\n  alt: string;\n  width?: number;\n  height?: number;\n \
    \ className?: string;\n  lazy?: boolean;\n  placeholder?: string;\n  sizes?: string;\n\
    \  priority?: boolean;\n}\n\nexport const OptimizedImage: React.FC<OptimizedImageProps>\
    \ = ({\n  src,\n  alt,\n  width,\n  height,\n  className,\n  lazy = true,\n  placeholder,\n\
    \  sizes,\n  priority = false,\n}) => {\n  const [isLoaded, setIsLoaded] = useState(false);\n\
    \  const [isInView, setIsInView] = useState(!lazy || priority);\n  const imgRef\
    \ = useRef<HTMLImageElement>(null);\n\n  // Intersection Observer for lazy loading\n\
    \  useEffect(() => {\n    if (!lazy || priority || isInView) return;\n\n    const\
    \ observer = new IntersectionObserver(\n      ([entry]) => {\n        if (entry.isIntersecting)\
    \ {\n          setIsInView(true);\n          observer.disconnect();\n        }\n\
    \      },\n      { threshold: 0.1 }\n    );\n\n    if (imgRef.current) {\n   \
    \   observer.observe(imgRef.current);\n    }\n\n    return () => observer.disconnect();\n\
    \  }, [lazy, priority, isInView]);\n\n  // Generate responsive image URLs\n  const\
    \ generateSrcSet = (baseSrc: string) => {\n    const widths = [320, 640, 768,\
    \ 1024, 1280, 1536];\n    return widths\n      .map(w => `${baseSrc}?w=${w} ${w}w`)\n\
    \      .join(', ');\n  };\n\n  // Generate WebP alternative\n  const getWebPSrc\
    \ = (src: string) => {\n    return src.replace(/\\.(jpg|jpeg|png)$/i, '.webp');\n\
    \  };\n\n  return (\n    <div className={`optimized-image ${className || ''}`}>\n\
    \      {placeholder && !isLoaded && (\n        <div className=\"image-placeholder\"\
    >\n          <img src={placeholder} alt=\"\" aria-hidden=\"true\" />\n       \
    \ </div>\n      )}\n\n      {isInView && (\n        <picture>\n          <source\n\
    \            srcSet={generateSrcSet(getWebPSrc(src))}\n            sizes={sizes}\n\
    \            type=\"image/webp\"\n          />\n          <img\n            ref={imgRef}\n\
    \            src={src}\n            srcSet={generateSrcSet(src)}\n           \
    \ sizes={sizes}\n            alt={alt}\n            width={width}\n          \
    \  height={height}\n            loading={lazy && !priority ? 'lazy' : 'eager'}\n\
    \            onLoad={() => setIsLoaded(true)}\n            style={{\n        \
    \      opacity: isLoaded ? 1 : 0,\n              transition: 'opacity 0.3s ease',\n\
    \            }}\n          />\n        </picture>\n      )}\n    </div>\n  );\n\
    };\n```\n\n### 4.2 Bundle Optimization\n\n#### Code Splitting Strategies **[REQUIRED]**\n\
    ```typescript\n// utils/loadable.tsx\nimport React, { Suspense, ComponentType\
    \ } from 'react';\n\ninterface LoadableOptions {\n  fallback?: React.ComponentType;\n\
    \  delay?: number;\n}\n\nexport function loadable<T extends ComponentType<any>>(\n\
    \  importFunc: () => Promise<{ default: T }>,\n  options: LoadableOptions = {}\n\
    ) {\n  const LazyComponent = React.lazy(importFunc);\n\n  return function LoadableComponent(props:\
    \ React.ComponentProps<T>) {\n    return (\n      <Suspense fallback={options.fallback\
    \ ? <options.fallback /> : <div>Loading...</div>}>\n        <LazyComponent {...props}\
    \ />\n      </Suspense>\n    );\n  };\n}\n\n// Route-based code splitting\nconst\
    \ Dashboard = loadable(() => import('@pages/Dashboard'), {\n  fallback: () =>\
    \ <PageSkeleton />,\n});\n\nconst UserProfile = loadable(() => import('@pages/UserProfile'),\
    \ {\n  fallback: () => <PageSkeleton />,\n});\n\n// Feature-based code splitting\n\
    const ChartComponent = loadable(() => import('@components/Chart'), {\n  fallback:\
    \ () => <ChartSkeleton />,\n});\n\n// Preload critical routes\nexport const preloadRoutes\
    \ = () => {\n  // Preload likely next routes\n  const routes = [\n    () => import('@pages/Dashboard'),\n\
    \    () => import('@pages/UserProfile'),\n  ];\n\n  routes.forEach(route => {\n\
    \    route().catch(() => {\n      // Silently handle preload failures\n    });\n\
    \  });\n};\n\n// webpack.config.js optimization\nmodule.exports = {\n  optimization:\
    \ {\n    splitChunks: {\n      chunks: 'all',\n      cacheGroups: {\n        //\
    \ Vendor chunk for stable dependencies\n        vendor: {\n          test: /[\\\
    \\/]node_modules[\\\\/]/,\n          name: 'vendors',\n          chunks: 'all',\n\
    \          priority: 10,\n          reuseExistingChunk: true,\n        },\n  \
    \      // Common chunk for shared code\n        common: {\n          name: 'common',\n\
    \          minChunks: 2,\n          chunks: 'all',\n          priority: 5,\n \
    \         reuseExistingChunk: true,\n        },\n        // React chunk\n    \
    \    react: {\n          test: /[\\\\/]node_modules[\\\\/](react|react-dom)[\\\
    \\/]/,\n          name: 'react',\n          chunks: 'all',\n          priority:\
    \ 20,\n        },\n      },\n    },\n    runtimeChunk: 'single',\n  },\n};\n```\n\
    \n---"
  5. Progressive Web Apps (PWA): "### 5.1 Service Worker Implementation\n\n#### Service\
    \ Worker Strategy **[REQUIRED]**\n```typescript\n// service-worker.ts\nconst CACHE_NAME\
    \ = 'app-v1.0.0';\nconst STATIC_CACHE = 'static-v1.0.0';\nconst DYNAMIC_CACHE\
    \ = 'dynamic-v1.0.0';\n\nconst STATIC_ASSETS = [\n  '/',\n  '/static/js/bundle.js',\n\
    \  '/static/css/main.css',\n  '/manifest.json',\n  '/offline.html',\n];\n\nconst\
    \ API_CACHE_STRATEGY = {\n  '/api/users': 'networkFirst',\n  '/api/settings':\
    \ 'cacheFirst',\n  '/api/notifications': 'networkOnly',\n};\n\n// Install event\n\
    self.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open(STATIC_CACHE)\n\
    \      .then(cache => cache.addAll(STATIC_ASSETS))\n      .then(() => self.skipWaiting())\n\
    \  );\n});\n\n// Activate event\nself.addEventListener('activate', (event) =>\
    \ {\n  event.waitUntil(\n    caches.keys()\n      .then(cacheNames => {\n    \
    \    return Promise.all(\n          cacheNames\n            .filter(cacheName\
    \ =>\n              cacheName !== STATIC_CACHE &&\n              cacheName !==\
    \ DYNAMIC_CACHE\n            )\n            .map(cacheName => caches.delete(cacheName))\n\
    \        );\n      })\n      .then(() => self.clients.claim())\n  );\n});\n\n\
    // Fetch event with different strategies\nself.addEventListener('fetch', (event)\
    \ => {\n  const { request } = event;\n  const url = new URL(request.url);\n\n\
    \  // Handle API requests\n  if (url.pathname.startsWith('/api/')) {\n    const\
    \ strategy = getApiCacheStrategy(url.pathname);\n    event.respondWith(handleApiRequest(request,\
    \ strategy));\n    return;\n  }\n\n  // Handle static assets\n  if (STATIC_ASSETS.includes(url.pathname))\
    \ {\n    event.respondWith(cacheFirst(request, STATIC_CACHE));\n    return;\n\
    \  }\n\n  // Handle navigation requests\n  if (request.mode === 'navigate') {\n\
    \    event.respondWith(networkFirst(request));\n    return;\n  }\n\n  // Default:\
    \ network first with dynamic cache\n  event.respondWith(networkFirst(request,\
    \ DYNAMIC_CACHE));\n});\n\n// Cache strategies\nasync function cacheFirst(request,\
    \ cacheName = DYNAMIC_CACHE) {\n  const cachedResponse = await caches.match(request);\n\
    \  if (cachedResponse) {\n    return cachedResponse;\n  }\n\n  try {\n    const\
    \ networkResponse = await fetch(request);\n    const cache = await caches.open(cacheName);\n\
    \    cache.put(request, networkResponse.clone());\n    return networkResponse;\n\
    \  } catch (error) {\n    if (request.mode === 'navigate') {\n      return caches.match('/offline.html');\n\
    \    }\n    throw error;\n  }\n}\n\nasync function networkFirst(request, cacheName\
    \ = DYNAMIC_CACHE) {\n  try {\n    const networkResponse = await fetch(request);\n\
    \    const cache = await caches.open(cacheName);\n    cache.put(request, networkResponse.clone());\n\
    \    return networkResponse;\n  } catch (error) {\n    const cachedResponse =\
    \ await caches.match(request);\n    if (cachedResponse) {\n      return cachedResponse;\n\
    \    }\n\n    if (request.mode === 'navigate') {\n      return caches.match('/offline.html');\n\
    \    }\n    throw error;\n  }\n}\n\nfunction getApiCacheStrategy(pathname) {\n\
    \  for (const [pattern, strategy] of Object.entries(API_CACHE_STRATEGY)) {\n \
    \   if (pathname.startsWith(pattern)) {\n      return strategy;\n    }\n  }\n\
    \  return 'networkFirst';\n}\n\n// Background sync for offline actions\nself.addEventListener('sync',\
    \ (event) => {\n  if (event.tag === 'background-sync') {\n    event.waitUntil(doBackgroundSync());\n\
    \  }\n});\n\nasync function doBackgroundSync() {\n  // Process offline actions\
    \ queue\n  const offlineActions = await getOfflineActions();\n\n  for (const action\
    \ of offlineActions) {\n    try {\n      await processOfflineAction(action);\n\
    \      await removeOfflineAction(action.id);\n    } catch (error) {\n      console.error('Failed\
    \ to sync offline action:', error);\n    }\n  }\n}\n```\n\n#### PWA Manifest Configuration\
    \ **[REQUIRED]**\n```json\n{\n  \"name\": \"Modern Web Application\",\n  \"short_name\"\
    : \"ModernApp\",\n  \"description\": \"A modern progressive web application\"\
    ,\n  \"start_url\": \"/\",\n  \"display\": \"standalone\",\n  \"orientation\"\
    : \"portrait-primary\",\n  \"theme_color\": \"#000000\",\n  \"background_color\"\
    : \"#ffffff\",\n  \"scope\": \"/\",\n  \"lang\": \"en\",\n  \"categories\": [\"\
    productivity\", \"business\"],\n  \"screenshots\": [\n    {\n      \"src\": \"\
    /images/screenshot-mobile.png\",\n      \"sizes\": \"640x1136\",\n      \"type\"\
    : \"image/png\",\n      \"form_factor\": \"narrow\"\n    },\n    {\n      \"src\"\
    : \"/images/screenshot-desktop.png\",\n      \"sizes\": \"1280x720\",\n      \"\
    type\": \"image/png\",\n      \"form_factor\": \"wide\"\n    }\n  ],\n  \"icons\"\
    : [\n    {\n      \"src\": \"/icons/icon-72x72.png\",\n      \"sizes\": \"72x72\"\
    ,\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable any\"\n    },\n\
    \    {\n      \"src\": \"/icons/icon-96x96.png\",\n      \"sizes\": \"96x96\"\
    ,\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable any\"\n    },\n\
    \    {\n      \"src\": \"/icons/icon-128x128.png\",\n      \"sizes\": \"128x128\"\
    ,\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable any\"\n    },\n\
    \    {\n      \"src\": \"/icons/icon-144x144.png\",\n      \"sizes\": \"144x144\"\
    ,\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable any\"\n    },\n\
    \    {\n      \"src\": \"/icons/icon-152x152.png\",\n      \"sizes\": \"152x152\"\
    ,\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable any\"\n    },\n\
    \    {\n      \"src\": \"/icons/icon-192x192.png\",\n      \"sizes\": \"192x192\"\
    ,\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable any\"\n    },\n\
    \    {\n      \"src\": \"/icons/icon-384x384.png\",\n      \"sizes\": \"384x384\"\
    ,\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable any\"\n    },\n\
    \    {\n      \"src\": \"/icons/icon-512x512.png\",\n      \"sizes\": \"512x512\"\
    ,\n      \"type\": \"image/png\",\n      \"purpose\": \"maskable any\"\n    }\n\
    \  ],\n  \"shortcuts\": [\n    {\n      \"name\": \"Dashboard\",\n      \"short_name\"\
    : \"Dashboard\",\n      \"description\": \"Open the dashboard\",\n      \"url\"\
    : \"/dashboard\",\n      \"icons\": [\n        {\n          \"src\": \"/icons/dashboard-96x96.png\"\
    ,\n          \"sizes\": \"96x96\"\n        }\n      ]\n    },\n    {\n      \"\
    name\": \"Profile\",\n      \"short_name\": \"Profile\",\n      \"description\"\
    : \"View profile\",\n      \"url\": \"/profile\",\n      \"icons\": [\n      \
    \  {\n          \"src\": \"/icons/profile-96x96.png\",\n          \"sizes\": \"\
    96x96\"\n        }\n      ]\n    }\n  ]\n}\n```\n\n### 5.2 Offline Functionality\n\
    \n#### Offline Data Management **[REQUIRED]**\n```typescript\n// utils/offlineStorage.ts\n\
    interface OfflineAction {\n  id: string;\n  type: string;\n  payload: any;\n \
    \ timestamp: number;\n  retryCount: number;\n}\n\nclass OfflineManager {\n  private\
    \ dbName = 'app-offline-db';\n  private version = 1;\n  private db: IDBDatabase\
    \ | null = null;\n\n  async init(): Promise<void> {\n    return new Promise((resolve,\
    \ reject) => {\n      const request = indexedDB.open(this.dbName, this.version);\n\
    \n      request.onerror = () => reject(request.error);\n      request.onsuccess\
    \ = () => {\n        this.db = request.result;\n        resolve();\n      };\n\
    \n      request.onupgradeneeded = (event) => {\n        const db = (event.target\
    \ as IDBOpenDBRequest).result;\n\n        // Create object stores\n        if\
    \ (!db.objectStoreNames.contains('actions')) {\n          const actionStore =\
    \ db.createObjectStore('actions', { keyPath: 'id' });\n          actionStore.createIndex('timestamp',\
    \ 'timestamp');\n        }\n\n        if (!db.objectStoreNames.contains('cache'))\
    \ {\n          const cacheStore = db.createObjectStore('cache', { keyPath: 'key'\
    \ });\n          cacheStore.createIndex('expiry', 'expiry');\n        }\n    \
    \  };\n    });\n  }\n\n  async addOfflineAction(action: Omit<OfflineAction, 'id'\
    \ | 'timestamp' | 'retryCount'>): Promise<void> {\n    if (!this.db) throw new\
    \ Error('Database not initialized');\n\n    const offlineAction: OfflineAction\
    \ = {\n      ...action,\n      id: crypto.randomUUID(),\n      timestamp: Date.now(),\n\
    \      retryCount: 0,\n    };\n\n    const transaction = this.db.transaction(['actions'],\
    \ 'readwrite');\n    const store = transaction.objectStore('actions');\n    await\
    \ store.add(offlineAction);\n  }\n\n  async getOfflineActions(): Promise<OfflineAction[]>\
    \ {\n    if (!this.db) throw new Error('Database not initialized');\n\n    const\
    \ transaction = this.db.transaction(['actions'], 'readonly');\n    const store\
    \ = transaction.objectStore('actions');\n    const request = store.getAll();\n\
    \n    return new Promise((resolve, reject) => {\n      request.onsuccess = ()\
    \ => resolve(request.result);\n      request.onerror = () => reject(request.error);\n\
    \    });\n  }\n\n  async removeOfflineAction(id: string): Promise<void> {\n  \
    \  if (!this.db) throw new Error('Database not initialized');\n\n    const transaction\
    \ = this.db.transaction(['actions'], 'readwrite');\n    const store = transaction.objectStore('actions');\n\
    \    await store.delete(id);\n  }\n\n  async cacheData(key: string, data: any,\
    \ ttl: number = 3600000): Promise<void> {\n    if (!this.db) throw new Error('Database\
    \ not initialized');\n\n    const cacheItem = {\n      key,\n      data,\n   \
    \   expiry: Date.now() + ttl,\n    };\n\n    const transaction = this.db.transaction(['cache'],\
    \ 'readwrite');\n    const store = transaction.objectStore('cache');\n    await\
    \ store.put(cacheItem);\n  }\n\n  async getCachedData(key: string): Promise<any\
    \ | null> {\n    if (!this.db) throw new Error('Database not initialized');\n\n\
    \    const transaction = this.db.transaction(['cache'], 'readonly');\n    const\
    \ store = transaction.objectStore('cache');\n    const request = store.get(key);\n\
    \n    return new Promise((resolve, reject) => {\n      request.onsuccess = ()\
    \ => {\n        const result = request.result;\n        if (!result || result.expiry\
    \ < Date.now()) {\n          resolve(null);\n        } else {\n          resolve(result.data);\n\
    \        }\n      };\n      request.onerror = () => reject(request.error);\n \
    \   });\n  }\n}\n\nexport const offlineManager = new OfflineManager();\n\n// React\
    \ hook for offline functionality\nexport function useOffline() {\n  const [isOnline,\
    \ setIsOnline] = useState(navigator.onLine);\n  const [hasOfflineActions, setHasOfflineActions]\
    \ = useState(false);\n\n  useEffect(() => {\n    const handleOnline = () => setIsOnline(true);\n\
    \    const handleOffline = () => setIsOnline(false);\n\n    window.addEventListener('online',\
    \ handleOnline);\n    window.addEventListener('offline', handleOffline);\n\n \
    \   return () => {\n      window.removeEventListener('online', handleOnline);\n\
    \      window.removeEventListener('offline', handleOffline);\n    };\n  }, []);\n\
    \n  useEffect(() => {\n    if (isOnline) {\n      // Sync offline actions when\
    \ coming back online\n      syncOfflineActions();\n    }\n  }, [isOnline]);\n\n\
    \  const syncOfflineActions = async () => {\n    try {\n      const actions =\
    \ await offlineManager.getOfflineActions();\n      setHasOfflineActions(actions.length\
    \ > 0);\n\n      for (const action of actions) {\n        try {\n          await\
    \ processOfflineAction(action);\n          await offlineManager.removeOfflineAction(action.id);\n\
    \        } catch (error) {\n          console.error('Failed to sync action:',\
    \ error);\n        }\n      }\n\n      setHasOfflineActions(false);\n    } catch\
    \ (error) {\n      console.error('Failed to sync offline actions:', error);\n\
    \    }\n  };\n\n  const addOfflineAction = async (type: string, payload: any)\
    \ => {\n    await offlineManager.addOfflineAction({ type, payload });\n    setHasOfflineActions(true);\n\
    \  };\n\n  return {\n    isOnline,\n    hasOfflineActions,\n    addOfflineAction,\n\
    \    syncOfflineActions,\n  };\n}\n```\n\n---"
  6. Mobile Development Standards: "### 6.1 React Native Standards\n\n#### Project\
    \ Structure **[REQUIRED]**\n```\nmobile-app/\n\u251C\u2500\u2500 src/\n\u2502\
    \   \u251C\u2500\u2500 components/            # Reusable components\n\u2502  \
    \ \u2502   \u251C\u2500\u2500 common/\n\u2502   \u2502   \u251C\u2500\u2500 forms/\n\
    \u2502   \u2502   \u2514\u2500\u2500 navigation/\n\u2502   \u251C\u2500\u2500\
    \ screens/              # Screen components\n\u2502   \u2502   \u251C\u2500\u2500\
    \ Auth/\n\u2502   \u2502   \u251C\u2500\u2500 Home/\n\u2502   \u2502   \u2514\u2500\
    \u2500 Profile/\n\u2502   \u251C\u2500\u2500 navigation/           # Navigation\
    \ configuration\n\u2502   \u251C\u2500\u2500 services/             # API and services\n\
    \u2502   \u251C\u2500\u2500 store/                # State management\n\u2502 \
    \  \u251C\u2500\u2500 hooks/                # Custom hooks\n\u2502   \u251C\u2500\
    \u2500 utils/                # Utility functions\n\u2502   \u251C\u2500\u2500\
    \ types/                # TypeScript types\n\u2502   \u251C\u2500\u2500 styles/\
    \               # Styling\n\u2502   \u2502   \u251C\u2500\u2500 colors.ts\n\u2502\
    \   \u2502   \u251C\u2500\u2500 typography.ts\n\u2502   \u2502   \u2514\u2500\u2500\
    \ spacing.ts\n\u2502   \u2514\u2500\u2500 assets/               # Images, fonts\n\
    \u251C\u2500\u2500 android/                  # Android-specific code\n\u251C\u2500\
    \u2500 ios/                      # iOS-specific code\n\u251C\u2500\u2500 __tests__/\
    \                # Test files\n\u251C\u2500\u2500 metro.config.js           #\
    \ Metro bundler config\n\u251C\u2500\u2500 babel.config.js           # Babel configuration\n\
    \u251C\u2500\u2500 react-native.config.js    # RN configuration\n\u2514\u2500\u2500\
    \ package.json\n```\n\n#### Component Development **[REQUIRED]**\n```typescript\n\
    // components/Button/Button.tsx\nimport React from 'react';\nimport {\n  TouchableOpacity,\n\
    \  Text,\n  ActivityIndicator,\n  StyleSheet,\n  ViewStyle,\n  TextStyle,\n} from\
    \ 'react-native';\nimport { colors, typography, spacing } from '@styles/index';\n\
    \ninterface ButtonProps {\n  title: string;\n  onPress: () => void;\n  variant?:\
    \ 'primary' | 'secondary' | 'danger';\n  size?: 'small' | 'medium' | 'large';\n\
    \  disabled?: boolean;\n  loading?: boolean;\n  style?: ViewStyle;\n  textStyle?:\
    \ TextStyle;\n  testID?: string;\n}\n\nexport const Button: React.FC<ButtonProps>\
    \ = ({\n  title,\n  onPress,\n  variant = 'primary',\n  size = 'medium',\n  disabled\
    \ = false,\n  loading = false,\n  style,\n  textStyle,\n  testID,\n}) => {\n \
    \ const buttonStyle = [\n    styles.base,\n    styles[variant],\n    styles[size],\n\
    \    disabled && styles.disabled,\n    style,\n  ];\n\n  const titleStyle = [\n\
    \    styles.text,\n    styles[`${variant}Text`],\n    styles[`${size}Text`],\n\
    \    disabled && styles.disabledText,\n    textStyle,\n  ];\n\n  return (\n  \
    \  <TouchableOpacity\n      style={buttonStyle}\n      onPress={onPress}\n   \
    \   disabled={disabled || loading}\n      activeOpacity={0.7}\n      testID={testID}\n\
    \    >\n      {loading ? (\n        <ActivityIndicator\n          size=\"small\"\
    \n          color={variant === 'primary' ? colors.white : colors.primary}\n  \
    \      />\n      ) : (\n        <Text style={titleStyle}>{title}</Text>\n    \
    \  )}\n    </TouchableOpacity>\n  );\n};\n\nconst styles = StyleSheet.create({\n\
    \  base: {\n    borderRadius: 8,\n    alignItems: 'center',\n    justifyContent:\
    \ 'center',\n    flexDirection: 'row',\n  },\n\n  // Variants\n  primary: {\n\
    \    backgroundColor: colors.primary,\n  },\n  secondary: {\n    backgroundColor:\
    \ colors.secondary,\n    borderWidth: 1,\n    borderColor: colors.primary,\n \
    \ },\n  danger: {\n    backgroundColor: colors.danger,\n  },\n\n  // Sizes\n \
    \ small: {\n    paddingHorizontal: spacing.sm,\n    paddingVertical: spacing.xs,\n\
    \    minHeight: 32,\n  },\n  medium: {\n    paddingHorizontal: spacing.md,\n \
    \   paddingVertical: spacing.sm,\n    minHeight: 44,\n  },\n  large: {\n    paddingHorizontal:\
    \ spacing.lg,\n    paddingVertical: spacing.md,\n    minHeight: 56,\n  },\n\n\
    \  // States\n  disabled: {\n    opacity: 0.5,\n  },\n\n  // Text styles\n  text:\
    \ {\n    fontFamily: typography.semiBold,\n    textAlign: 'center',\n  },\n  primaryText:\
    \ {\n    color: colors.white,\n  },\n  secondaryText: {\n    color: colors.primary,\n\
    \  },\n  dangerText: {\n    color: colors.white,\n  },\n  smallText: {\n    fontSize:\
    \ 14,\n  },\n  mediumText: {\n    fontSize: 16,\n  },\n  largeText: {\n    fontSize:\
    \ 18,\n  },\n  disabledText: {\n    opacity: 0.7,\n  },\n});\n```\n\n#### Navigation\
    \ Setup **[REQUIRED]**\n```typescript\n// navigation/AppNavigator.tsx\nimport\
    \ React from 'react';\nimport { NavigationContainer } from '@react-navigation/native';\n\
    import { createNativeStackNavigator } from '@react-navigation/native-stack';\n\
    import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';\nimport\
    \ { useAuthStore } from '@store/authStore';\n\n// Type definitions for navigation\n\
    export type RootStackParamList = {\n  Auth: undefined;\n  Main: undefined;\n \
    \ Profile: { userId: string };\n  Settings: undefined;\n};\n\nexport type TabParamList\
    \ = {\n  Home: undefined;\n  Search: undefined;\n  Profile: undefined;\n};\n\n\
    const Stack = createNativeStackNavigator<RootStackParamList>();\nconst Tab = createBottomTabNavigator<TabParamList>();\n\
    \nconst TabNavigator = () => {\n  return (\n    <Tab.Navigator\n      screenOptions={{\n\
    \        headerShown: false,\n        tabBarActiveTintColor: colors.primary,\n\
    \        tabBarInactiveTintColor: colors.textSecondary,\n      }}\n    >\n   \
    \   <Tab.Screen\n        name=\"Home\"\n        component={HomeScreen}\n     \
    \   options={{\n          tabBarIcon: ({ color, size }) => (\n            <Icon\
    \ name=\"home\" size={size} color={color} />\n          ),\n        }}\n     \
    \ />\n      <Tab.Screen\n        name=\"Search\"\n        component={SearchScreen}\n\
    \        options={{\n          tabBarIcon: ({ color, size }) => (\n          \
    \  <Icon name=\"search\" size={size} color={color} />\n          ),\n        }}\n\
    \      />\n      <Tab.Screen\n        name=\"Profile\"\n        component={ProfileScreen}\n\
    \        options={{\n          tabBarIcon: ({ color, size }) => (\n          \
    \  <Icon name=\"user\" size={size} color={color} />\n          ),\n        }}\n\
    \      />\n    </Tab.Navigator>\n  );\n};\n\nexport const AppNavigator = () =>\
    \ {\n  const { isAuthenticated } = useAuthStore();\n\n  return (\n    <NavigationContainer>\n\
    \      <Stack.Navigator screenOptions={{ headerShown: false }}>\n        {isAuthenticated\
    \ ? (\n          <>\n            <Stack.Screen name=\"Main\" component={TabNavigator}\
    \ />\n            <Stack.Screen\n              name=\"Profile\"\n            \
    \  component={ProfileScreen}\n              options={{ presentation: 'modal' }}\n\
    \            />\n            <Stack.Screen name=\"Settings\" component={SettingsScreen}\
    \ />\n          </>\n        ) : (\n          <Stack.Screen name=\"Auth\" component={AuthScreen}\
    \ />\n        )}\n      </Stack.Navigator>\n    </NavigationContainer>\n  );\n\
    };\n```\n\n### 6.2 Platform-Specific Optimizations\n\n#### iOS Guidelines **[REQUIRED]**\n\
    ```typescript\n// utils/platform.ts\nimport { Platform, Dimensions } from 'react-native';\n\
    \nexport const isIOS = Platform.OS === 'ios';\nexport const isAndroid = Platform.OS\
    \ === 'android';\n\nexport const { width: screenWidth, height: screenHeight }\
    \ = Dimensions.get('window');\n\n// Safe area handling for iOS\nimport { useSafeAreaInsets\
    \ } from 'react-native-safe-area-context';\n\nexport const SafeAreaView: React.FC<{\
    \ children: React.ReactNode }> = ({ children }) => {\n  const insets = useSafeAreaInsets();\n\
    \n  return (\n    <View\n      style={{\n        flex: 1,\n        paddingTop:\
    \ insets.top,\n        paddingBottom: insets.bottom,\n        paddingLeft: insets.left,\n\
    \        paddingRight: insets.right,\n      }}\n    >\n      {children}\n    </View>\n\
    \  );\n};\n\n// Platform-specific styling\nexport const createPlatformStyles =\
    \ (iosStyle: any, androidStyle: any) => {\n  return Platform.select({\n    ios:\
    \ iosStyle,\n    android: androidStyle,\n  });\n};\n\n// Performance optimizations\n\
    export const useKeyboardHeight = () => {\n  const [keyboardHeight, setKeyboardHeight]\
    \ = useState(0);\n\n  useEffect(() => {\n    const showEvent = isIOS ? 'keyboardWillShow'\
    \ : 'keyboardDidShow';\n    const hideEvent = isIOS ? 'keyboardWillHide' : 'keyboardDidHide';\n\
    \n    const showListener = Keyboard.addListener(showEvent, (e) => {\n      setKeyboardHeight(e.endCoordinates.height);\n\
    \    });\n\n    const hideListener = Keyboard.addListener(hideEvent, () => {\n\
    \      setKeyboardHeight(0);\n    });\n\n    return () => {\n      showListener.remove();\n\
    \      hideListener.remove();\n    };\n  }, []);\n\n  return keyboardHeight;\n\
    };\n```\n\n#### Android Guidelines **[REQUIRED]**\n```xml\n<!-- android/app/src/main/res/values/styles.xml\
    \ -->\n<resources>\n    <style name=\"AppTheme\" parent=\"Theme.AppCompat.DayNight.NoActionBar\"\
    >\n        <item name=\"android:editTextBackground\">@drawable/rn_edit_text_material</item>\n\
    \        <item name=\"android:statusBarColor\">@android:color/transparent</item>\n\
    \        <item name=\"android:windowLightStatusBar\">true</item>\n        <item\
    \ name=\"android:navigationBarColor\">@android:color/transparent</item>\n    \
    \    <item name=\"android:windowLightNavigationBar\">true</item>\n    </style>\n\
    </resources>\n```\n\n```typescript\n// Android-specific optimizations\nimport\
    \ { BackHandler } from 'react-native';\n\nexport const useBackHandler = (handler:\
    \ () => boolean) => {\n  useEffect(() => {\n    if (isAndroid) {\n      const\
    \ backHandler = BackHandler.addEventListener('hardwareBackPress', handler);\n\
    \      return () => backHandler.remove();\n    }\n  }, [handler]);\n};\n\n// Permission\
    \ handling\nimport { PermissionsAndroid } from 'react-native';\n\nexport const\
    \ requestPermissions = async () => {\n  if (isAndroid) {\n    try {\n      const\
    \ granted = await PermissionsAndroid.requestMultiple([\n        PermissionsAndroid.PERMISSIONS.CAMERA,\n\
    \        PermissionsAndroid.PERMISSIONS.WRITE_EXTERNAL_STORAGE,\n        PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,\n\
    \      ]);\n\n      return Object.values(granted).every(\n        permission =>\
    \ permission === PermissionsAndroid.RESULTS.GRANTED\n      );\n    } catch (err)\
    \ {\n      console.warn(err);\n      return false;\n    }\n  }\n  return true;\n\
    };\n```\n\n---"
  Implementation Checklist: '### Frontend Architecture

    - [ ] Project structure follows standards

    - [ ] TypeScript configured with strict settings

    - [ ] Build system optimized

    - [ ] Component architecture defined

    - [ ] Error boundaries implemented


    ### Framework Implementation

    - [ ] Framework-specific patterns applied

    - [ ] Performance optimizations implemented

    - [ ] Code splitting configured

    - [ ] State management setup

    - [ ] Testing framework integrated


    ### Performance Optimization

    - [ ] Core Web Vitals monitored

    - [ ] Images optimized

    - [ ] Bundle size optimized

    - [ ] Lazy loading implemented

    - [ ] Caching strategies applied


    ### PWA Features

    - [ ] Service worker implemented

    - [ ] Manifest configured

    - [ ] Offline functionality working

    - [ ] Background sync setup

    - [ ] Installation prompts added


    ### Mobile Development

    - [ ] Platform-specific optimizations

    - [ ] Navigation configured

    - [ ] Performance optimized

    - [ ] Native features integrated

    - [ ] Testing on real devices


    ### Testing and Quality

    - [ ] Unit tests comprehensive

    - [ ] Integration tests working

    - [ ] E2E tests automated

    - [ ] Performance tests defined

    - [ ] Accessibility tests included


    ---


    **End of Frontend and Mobile Development Standards**'
metadata:
  version: 1.0.0
  last_updated: '2025-06-20T05:11:53.631945'
  source: williamzujkowski/standards/docs/standards/FRONTEND_MOBILE_STANDARDS.md
  checksum: 2dd5a4b437974005c8eed59032264a3822567f05f62c1ba267ac80545461a62a
